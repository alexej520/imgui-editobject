package imgui.editobject.kotlin

import java.lang.ref.WeakReference
import java.util.*
import kotlin.reflect.*
import kotlin.reflect.full.allSuperclasses
import kotlin.reflect.full.declaredMemberProperties
import kotlin.reflect.full.isSubclassOf


@Suppress("UNCHECKED_CAST")
val <T : Any> KClass<T>.allDeclaredProperties: Collection<KProperty1<out Any, Any?>>
    get() {
        val cachedProperties = memberPropertiesCache[this as KClass<Any>]
        if (cachedProperties != null) {
            return cachedProperties
        }
        val properties = mutableListOf<KProperty1<out Any, Any?>>()
        try {
            properties += declaredMemberProperties
            allSuperclasses.forEach { kClass ->
                properties += kClass.declaredMemberProperties
            }
        } catch (e: UnsupportedOperationException) {
            // java.lang.UnsupportedOperationException: This class is an internal synthetic class generated by the Kotlin compiler, such as an anonymous class for a lambda, a SAM wrapper, a callable reference, etc.
        } catch (e: Error) {
            // kotlin.reflect.jvm.internal.KotlinReflectionInternalError: Reflection on built-in Kotlin types is not yet fully supported.
        }
        memberPropertiesCache[this] = properties
        return properties
    }

val KType.simpleName: String
    get() {
        val nullable = if (isMarkedNullable) "?" else ""
        val args = arguments
        val kClass = classifier as? KClass<*>
        if (kClass != null && kClass.isSubclassOf(Function::class)) {
            return StringBuilder().apply {
                if (isMarkedNullable) {
                    append('(')
                }
                append('(')
                val lastInIndex = args.size - 2
                (0..lastInIndex).forEach { index ->
                    append(args[index].simpleName)
                    if (index != lastInIndex) {
                        append(", ")
                    }
                }
                append(") -> ")
                append(args.last().simpleName)
                if (isMarkedNullable) {
                    append(')')
                    append(nullable)
                }
            }.toString()
        }
        val simpleKClassName = kClass?.simpleName
        return when {
            simpleKClassName == null -> toString()
            args.isEmpty() -> simpleKClassName + nullable
            else -> args.joinToString(
                    prefix = "$simpleKClassName<",
                    separator = ", ",
                    postfix = ">$nullable",
                    transform = {
                        it.simpleName
                    }
            )
        }
    }

val KTypeProjection.simpleName: String
    get() = StringBuilder().apply {
        variance?.simpleName?.let {
            append(it)
            append(' ')
        }
        append(type?.simpleName ?: this@simpleName)
    }.toString()

val KVariance.simpleName: String?
    get() = when (this) {
        KVariance.IN -> "in"
        KVariance.OUT -> "out"
        KVariance.INVARIANT -> null
        else -> null
    }


private val memberPropertiesCache = mutableMapOf<KClass<Any>, Collection<KProperty1<out Any, Any?>>>()

fun <T, R> KProperty1<T, R>.getProperty0(receiver: T): KProperty0<R> =
        if (this is KMutableProperty1<T, R>) {
            property0Cache.getOrPut(this) { FullWeakHashMap() }
                    .getOrPutWeak(receiver as Any) { MutableProperty0(this, receiver) }
                    as KProperty0<R>
        } else {
            property0Cache.getOrPut(this) { FullWeakHashMap() }
                    .getOrPutWeak(receiver as Any) { Property0(this, receiver) }
                    as KProperty0<R>
        }

private open class Property0<T, out R>(protected open val property1: KProperty1<T, R>, protected val receiver: T)
    : KProperty0<R> {
    override val annotations: List<Annotation> get() = property1.annotations
    override val getter: KProperty0.Getter<R> get() = Getter(this)
    override val isAbstract: Boolean get() = property1.isAbstract
    override fun get(): R = property1.get(receiver)
    override val isConst: Boolean get() = property1.isConst
    override val isFinal: Boolean get() = property1.isFinal
    override fun getDelegate(): Any? = property1.getDelegate(receiver)
    override val isLateinit: Boolean get() = property1.isLateinit
    override val isOpen: Boolean get() = property1.isOpen
    override val name: String get() = property1.name
    override val parameters: List<KParameter> get() = property1.parameters.run { subList(1, lastIndex) }
    override val returnType: KType get() = property1.returnType
    override val typeParameters: List<KTypeParameter> get() = property1.typeParameters.run { subList(1, lastIndex) }
    override val visibility: KVisibility? get() = property1.visibility
    override fun call(vararg args: Any?): R = getter.call(*args)
    override fun callBy(args: Map<KParameter, Any?>): R = getter.callBy(args)
    override fun invoke(): R = getter.invoke()
}

private open class Getter<out R>(
        override val property: KProperty0<R>
) : KProperty0.Getter<R> {
    override val annotations: List<Annotation> get() = throw UnsupportedOperationException()
    override val isAbstract: Boolean get() = property.isAbstract
    override val isExternal: Boolean get() = false
    override val isFinal: Boolean get() = property.isFinal
    override val isInfix: Boolean = false
    override val isOpen: Boolean get() = property.isOpen
    override val isInline: Boolean = false
    override val name: String get() = property.name
    override val isOperator: Boolean = false
    override val parameters: List<KParameter> get() = property.parameters.run { subList(1, lastIndex) }
    override val isSuspend: Boolean get() = false
    override val returnType: KType get() = property.returnType
    override val typeParameters: List<KTypeParameter> get() = property.typeParameters.run { subList(1, lastIndex) }
    override val visibility: KVisibility? get() = property.visibility
    override fun call(vararg args: Any?): R =
            if (args.isNotEmpty()) throw IllegalArgumentException() else property.get()

    override fun callBy(args: Map<KParameter, Any?>): R = property.get()
    override fun invoke(): R = property.get()
}

private class MutableProperty0<T, R>(override val property1: KMutableProperty1<T, R>, receiver: T)
    : Property0<T, R>(property1, receiver), KMutableProperty0<R> {
    override val setter: KMutableProperty0.Setter<R> get() = Setter(this)
    override fun set(value: R) = property1.set(receiver, value)
}

private class Setter<R>(
        override val property: KMutableProperty0<R>
) : KMutableProperty0.Setter<R> {
    override val annotations: List<Annotation> get() = throw UnsupportedOperationException()
    override val isAbstract: Boolean get() = property.isAbstract
    override val isExternal: Boolean get() = false
    override val isFinal: Boolean get() = property.isFinal
    override val isInfix: Boolean = false
    override val isOpen: Boolean get() = property.isOpen
    override val isInline: Boolean = false
    override val name: String get() = property.name
    override val isOperator: Boolean = false
    override val parameters: List<KParameter> get() = property.parameters.run { subList(1, lastIndex) }
    override val isSuspend: Boolean get() = false
    override val returnType: KType get() = property.returnType
    override val typeParameters: List<KTypeParameter> get() = property.typeParameters.run { subList(1, lastIndex) }
    override val visibility: KVisibility? get() = property.visibility
    override fun call(vararg args: Any?) =
            if (args.size != 1) throw IllegalArgumentException() else property.set(args[0] as R)

    override fun callBy(args: Map<KParameter, Any?>) = property.set(args[parameters[0]] as R)
    override fun invoke(p1: R) = property.set(p1)
}

private inline fun <K, V> FullWeakHashMap<K, V>.getOrPutWeak(key: K, defaultValue: () -> V): V {
    var value = get(key)?.get()
    if (value == null) {
        value = defaultValue()
        put(key, WeakReference(value))
    }
    return value!!
}

typealias FullWeakHashMap<K, V> = WeakHashMap<K, WeakReference<V>>

private val property0Cache = WeakHashMap<KProperty1<*, *>, FullWeakHashMap<Any, KProperty0<*>>>()
